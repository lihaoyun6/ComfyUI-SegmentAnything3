"""
SAM3 Point Collector - Interactive Point Selection

Point editor widget adapted from ComfyUI-KJNodes
Original: https://github.com/PozzettiAndrea/ComfyUI-SAM3
"""

import torch
import numpy as np
import json
import io
import base64
from PIL import Image


class SAM3PointCollector:
    """
    Interactive Point Collector for SAM3

    Displays image canvas in the node where users can click to add:
    - Positive points (Left-click) - green circles
    - Negative points (Shift+Left-click or Right-click) - red circles

    Outputs point arrays to feed into SAM3Segmentation node.
    """
    # Class-level cache for output results
    _cache = {}
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "image": ("IMAGE", {
                    "tooltip": "Image to display in interactive canvas. Left-click to add positive points (green), Shift+Left-click or Right-click to add negative points (red). Points are automatically normalized to image dimensions."
                }),
                "points_store": ("STRING", {"multiline": False, "default": "{}"}),
                "coordinates": ("STRING", {"multiline": False, "default": "[]"}),
                "neg_coordinates": ("STRING", {"multiline": False, "default": "[]"}),
            },
        }
    
    # === MODIFICATION 1: Change output types to STRING (Raw JSON Coordinates) ===
    RETURN_TYPES = ("STRING", "STRING")
    RETURN_NAMES = ("positive_coords", "negative_coords")
    FUNCTION = "collect_points"
    CATEGORY = "SAM3"
    OUTPUT_NODE = True
    
    @classmethod
    def IS_CHANGED(cls, image, points_store, coordinates, neg_coordinates):
        # Return hash based on actual point content, not object identity
        import hashlib
        h = hashlib.md5()
        h.update(str(image.shape).encode())
        h.update(coordinates.encode())
        h.update(neg_coordinates.encode())
        result = h.hexdigest()
        print(f"[IS_CHANGED DEBUG] SAM3PointCollector: shape={image.shape}, coords={coordinates}, neg_coords={neg_coordinates}")
        print(f"[IS_CHANGED DEBUG] SAM3PointCollector: returning hash={result}")
        return result
    
    def collect_points(self, image, points_store, coordinates, neg_coordinates):
        """
        Collect points from interactive canvas
        """
        # Create cache key from inputs
        import hashlib
        h = hashlib.md5()
        h.update(str(image.shape).encode())
        h.update(coordinates.encode())
        h.update(neg_coordinates.encode())
        cache_key = h.hexdigest()
        
        # === MODIFICATION 2: Cache logic updated for new outputs ===
        # We assume 'coordinates' and 'neg_coordinates' already contain the desired JSON strings from the UI widgets.
        
        # Check if we have cached result
        if cache_key in SAM3PointCollector._cache:
            cached = SAM3PointCollector._cache[cache_key]
            print(f"[SAM3 Point Collector] CACHE HIT - returning cached result for key={cache_key[:8]}")
            img_base64 = self.tensor_to_base64(image)
            return {
                "ui": {"bg_image": [img_base64]},
                "result": cached  # cached is (pos_json_str, neg_json_str)
            }
        
        print(f"[SAM3 Point Collector] CACHE MISS - computing new result for key={cache_key[:8]}")
        
        # The 'coordinates' and 'neg_coordinates' inputs are already the required JSON strings 
        # (e.g., '[{"x": 63, "y": 782}, ...]') generated by the JavaScript widget.
        raw_pos_coords_str = coordinates
        raw_neg_coords_str = neg_coordinates
        
        print(f"[SAM3 Point Collector] Raw Positive Output: {raw_pos_coords_str}")
        print(f"[SAM3 Point Collector] Raw Negative Output: {raw_neg_coords_str}")
        
        # We skip the normalization and SAM format conversion steps entirely.
        
        # Cache the result
        result = (raw_pos_coords_str, raw_neg_coords_str)
        SAM3PointCollector._cache[cache_key] = result
        
        # Send image back to widget as base64
        img_base64 = self.tensor_to_base64(image)
        
        return {
            "ui": {"bg_image": [img_base64]},
            "result": result
        }
    
    def tensor_to_base64(self, tensor):
        """Convert ComfyUI image tensor to base64 string for JavaScript widget"""
        # Convert from [B, H, W, C] to PIL Image
        # Take first image if batch
        img_array = tensor[0].cpu().numpy()
        # Convert from 0-1 float to 0-255 uint8
        img_array = (img_array * 255).astype(np.uint8)
        pil_img = Image.fromarray(img_array)
        
        # Convert to base64
        buffered = io.BytesIO()
        pil_img.save(buffered, format="JPEG", quality=75)
        img_bytes = buffered.getvalue()
        img_base64 = base64.b64encode(img_bytes).decode('utf-8')
        
        return img_base64


# Node mappings for ComfyUI registration
NODE_CLASS_MAPPINGS = {
    "SAM3PointCollector": SAM3PointCollector,
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "SAM3PointCollector": "SAM3 Point Editor",
}
